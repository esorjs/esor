{
  "version": 3,
  "sources": ["../src/hooks/reactivity.js", "../src/hooks/emit.js", "../src/hooks/ref.js", "../src/utils/dom.js", "../src/utils/error.js", "../src/template/reconcile.js", "../src/template/html.js", "../src/lifecycle.js", "../src/utils/parser.js", "../src/props.js", "../src/events.js", "../src/component.js"],
  "sourcesContent": ["let activeEffect = null;\nlet runCount = 0;\nconst subs = [];\nconst MAX_UPDATE_DEPTH = 100;\n\n/**\n * Creates a reactive signal that notifies subscribers when its value changes\n * @param {any} initialValue - Initial value\n * @returns {Function} A getter/setter function to access and modify the value\n */\nconst signal = (initial) => {\n    let val = initial;\n\n    const getterSetter = (value) => {\n        if (value === undefined) {\n            if (activeEffect && !subs.includes(activeEffect))\n                subs.push(activeEffect);\n            return val;\n        }\n\n        const computed = typeof value === \"function\" ? value(val) : value;\n        if (!Object.is(computed, val)) {\n            val = computed;\n            for (const sub of subs) sub();\n        }\n\n        return val;\n    };\n\n    return getterSetter;\n};\n\n/**\n * Creates a reactive effect that runs automatically when its dependencies change.\n * The effect is executed immediately and provides a cleanup function to handle any necessary cleanup logic.\n *\n * @param {Function} callback - The function to execute when the effect is triggered.\n *                              It can optionally return a cleanup function.\n * @returns {Function} A function to clean up the effect, preventing further executions and calling the cleanup logic.\n */\nconst effect = (fn) => {\n    let updateDepth = 0;\n    if (++updateDepth > MAX_UPDATE_DEPTH) {\n        console.warn(\"Maximum effect update depth exceeded\");\n        return;\n    }\n\n    const reactiveEffect = () => {\n        const prev = activeEffect;\n        activeEffect = reactiveEffect;\n        try {\n            fn();\n        } finally {\n            activeEffect = prev;\n            updateDepth--;\n        }\n    };\n\n    reactiveEffect();\n    return () => subs.splice(subs.indexOf(reactiveEffect), 1);\n};\n\n/**\n * Creates a computed reactive value that is derived from other signals.\n * The function is only executed when the computed value is accessed.\n * The computed value is cached and invalidated when its dependencies change.\n * The function returns a getter function with a `.dispose` method to clean up the computed value.\n * @param {Function} callback - The function to execute when the computed value is accessed.\n * @returns {Function} A getter function with a `.dispose` method to clean up the computed value.\n */\nconst computed = (fn) => {\n    const computedSignal = signal();\n    effect(() => computedSignal(fn()));\n    return () => computedSignal();\n};\n\n/**\n * Batches multiple signal updates into a single update, optimizing rendering performance.\n * This function is a no-op when called from within an effect.\n *\n * @param {Function} callback - The function to execute within the batch.\n * @returns {any} The result of the callback function.\n */\nconst batch = (fn) => {\n    const previous = activeEffect;\n    activeEffect = { id: runCount++ };\n    try {\n        return fn();\n    } finally {\n        activeEffect = previous;\n    }\n};\n\nexport { signal, effect, computed, batch };\n", "/**\n * Emits a custom event with the given name and detail\n * @param {string} name - name of the event\n * @param {*} detail - detail of the event\n * @param {EventTarget} [target=null] - target of the event\n * @returns {CustomEvent} - the emitted event\n */\nexport function emit(name, detail, target = null) {\n    const event = new CustomEvent(name, {\n        detail,\n        bubbles: true,\n        composed: true,\n        cancelable: true,\n    });\n\n    if (target) target.dispatchEvent(event);\n    return event;\n}\n", "/**\n * Creates a mutable reference to a value.\n *\n * @param {any} [initialValue=null] - The initial value for the reference.\n * @returns {Function} A getter/setter function for the reference value.\n */\nexport function ref(initialValue = null) {\n    let current = initialValue;\n    return (v) => (v !== undefined ? (current = v) : current);\n}\n", "/**\n * Marks a node to identify it as system-generated\n * @param {Node} node - The node to be marked\n * @returns {Node} The same node, allowing for chaining\n */\n\nexport function markNode(node) {\n    if (node) node.__nodeGroups = true;\n    return node;\n}\n\n/**\n * Creates a DocumentFragment from an array of nodes, marking each node\n * to identify it as system-generated.\n * @param {Array<Node>} nodes - Nodes to include in the fragment.\n * @returns {DocumentFragment} The created DocumentFragment containing the marked nodes.\n */\nexport function markedFragment(nodes) {\n    return createFragment(nodes, markNode);\n}\n\n/**\n * Creates a DocumentFragment from an array of nodes, optionally processing each node with a function.\n * @param {Array<Node>} nodes - Nodes to include in the fragment.\n * @param {Function} [fn=null] - Optional function to process each node. The function takes the node and the fragment as parameters and returns a processed node.\n * @param {Node} [parent=null] - Optional parent node to append the fragment to.\n * @returns {DocumentFragment} The created DocumentFragment containing the nodes.\n */\nexport function createFragment(nodes, fn = null, parent = null) {\n    const frag = document.createDocumentFragment();\n    if (!nodes?.length) return frag;\n    for (let node of nodes) {\n        if (!node) continue;\n        node = typeof fn === \"function\" ? fn(node, frag) : node;\n        Array.isArray(node)\n            ? frag.appendChild(createFragment(node, fn))\n            : frag.appendChild(node);\n    }\n    if (parent && frag.childNodes.length) parent.appendChild(frag);\n    return frag;\n}\n", "/**\n * Handles errors centrally with context\n * @param {string} context - Context of error (module or function)\n * @param {Error|string} error - Error or message\n * @param {string} [level=\u201Cerror\u201D] - Log level (error, warn, info)\n * @returns {Error} Error processed for possible additional handling\n */\nexport function handleError(context, error, level = \"error\") {\n    const method = level === \"warn\" ? console.warn : console.error;\n    const errorObj = error instanceof Error ? error : new Error(String(error));\n    method(`[Esor Framework Error] ${context}:`, errorObj.message);\n\n    return errorObj; // Allows chaining\n}\n\n/**\n * Executes code with built-in error handling\n * @param {Function} fn - Function to execute\n * @param {string} context - Context for error messages\n * @param {any} [fallback] - Default value if error occurs\n * @returns {any} Result of function or fallback\n */\nexport function tryCatch(fn, context, fallback) {\n    try {\n        return fn();\n    } catch (error) {\n        handleError(context, error);\n        return fallback;\n    }\n}\n", "import { markedFragment } from \"../utils/dom.js\";\nimport { tryCatch } from \"../utils/error.js\";\n\n/**\n * Reconciles the DOM nodes in a list by diffing the new data with the previous data.\n * This function is optimized for performance and should be used when the list data\n * is changed.\n * @param {Array<Node|Array<Node>>} newGroupsData - New list of nodes or arrays of nodes.\n * @param {Node} markerNode - Marker node to position the new nodes.\n * @throws {Error} If the new data is not an array or if any of the nodes are not DOM nodes.\n */\n\nexport function reconcile(newGroupsData, markerNode) {\n    if (!newGroupsData || !markerNode || !markerNode.parentNode) return;\n\n    tryCatch(() => {\n        const parent = markerNode.parentNode;\n\n        /**\n         * Removes nodes from the parent.\n         * @param {Array<Node>} nodes - Nodes to be removed.\n         */\n        const removeNodes = (nodes) => {\n            for (const node of nodes) {\n                if (!node || node.parentNode !== parent) continue;\n                if (node._cleanup && typeof node._cleanup === \"function\") node._cleanup();\n                parent.removeChild(node);\n            }\n        };\n\n        const prevGroups = markerNode.__nodeGroups || [];\n        const prevMap = new Map(prevGroups.map((g) => [g.key, g]));\n        const newGroups = newGroupsData.map((nodes, idx) => {\n            const group = Array.isArray(nodes)\n                ? nodes.filter(Boolean)\n                : [nodes];\n            const keyNode = group.find((n) => n?.getAttribute?.(\"key\") != null);\n            const key = keyNode ? keyNode.getAttribute(\"key\") : `__key_${idx}`;\n            const state = group.map((n) => n?.outerHTML || \"\").join(\"|\");\n            return { key, nodes: group, state };\n        });\n\n        const newMap = new Map(newGroups.map((g) => [g.key, g]));\n\n        for (const g of prevGroups) !newMap.has(g.key) && removeNodes(g.nodes); // Remove groups that no longer exist in the new list.\n\n        let lastNode = markerNode;\n        for (const newGroup of newGroups) {\n            const prevGroup = prevMap.get(newGroup.key);\n            if (prevGroup) {\n                // [UPDATE]\n                if (prevGroup.state !== newGroup.state) {\n                    removeNodes(prevGroup.nodes);\n                    parent.insertBefore(\n                        markedFragment(newGroup.nodes),\n                        lastNode.nextSibling\n                    );\n                } else {\n                    // [KEEP/MOVE]\n                    const firstNode = prevGroup.nodes[0];\n                    if (firstNode !== lastNode.nextSibling) {\n                        const fragment = document.createDocumentFragment();\n                        for (const node of prevGroup.nodes)\n                            fragment.appendChild(node);\n                        parent.insertBefore(fragment, lastNode.nextSibling);\n                    }\n\n                    newGroup.nodes = prevGroup.nodes; // Reuse nodes to avoid recreation\n                }\n            } else {\n                // [ADD]\n                parent.insertBefore(\n                    markedFragment(newGroup.nodes),\n                    lastNode.nextSibling\n                );\n            }\n\n            lastNode = newGroup.nodes[newGroup.nodes.length - 1] || lastNode;\n        }\n\n        markerNode.__nodeGroups = newGroups; // Update internal reference\n    }, \"list.reconcile\");\n}\n", "import { effect } from \"../hooks/reactivity.js\";\nimport { markedFragment, markNode } from \"../utils/dom.js\";\nimport { reconcile } from \"./reconcile.js\";\nimport { tryCatch } from \"../utils/error.js\";\n\nconst templCache = new WeakMap(); // Template cache\nconst MARKER = \"\\ufeff\\ufeff\"; // Invisible marker for processing\n\n/**\n * Inserts a fragment into the DOM\n * @ @param {DocumentFragment} fragment - Fragment to insert\n * @param {Node} parent - Parent Node\n * @param {Node} [node=null] - Reference Node\n * @private\n */\nfunction insertFragment(fragment, parent, node = null) {\n    if (!fragment || !parent) return;\n\n    node && node.parentNode === parent\n        ? parent.insertBefore(fragment, node)\n        : parent.appendChild(fragment);\n}\n\n/**\n * Applies a reference to a node\n * @param {Node} node - Target node\n * @param {Function|Object} value - Reference to apply\n * @private\n */\nfunction setRef(node, value) {\n    if (typeof value === \"function\") value(node);\n    else if (value && typeof value === \"object\" && \"current\" in value)\n        value.current = node;\n}\n\n/**\n * Applies an event to a node\n * @param {Node} node - Target node\n * @param {string} attr - Event attribute name (e.g. \"onclick\")\n * @param {Function} value - Event handler\n * @private\n */\nfunction setEvent(node, attr, value) {\n    const eventName = attr.slice(2).toLowerCase();\n    node.addEventListener(eventName, value);\n    node._cleanup = () => node.removeEventListener(eventName, value);\n}\n\n/**\n * Applies inline styles to a DOM node.\n *\n * Iterates over the style object and sets each style property on the node's\n * style attribute.\n *\n * @param {Node} node - The target node to apply styles to.\n * @param {Object} value - An object containing CSS style properties and values.\n * @private\n */\nfunction setStyle(node, value) {\n    Object.assign(node.style, value);\n}\n\n/**\n * Applies an attribute to a node.\n * If the attribute is \"value\" or \"checked\", it sets the corresponding property on the node.\n * If the value is false, the attribute is removed from the node.\n * Otherwise, the attribute is set with the provided value.\n *\n * @param {Node} node - The target node.\n * @param {string} attr - The name of the attribute.\n * @param {any} value - The value to apply.\n * @private\n */\n\nexport function setAttribute(node, attr, value) {\n    if (attr === \"value\" || attr === \"checked\") node[attr] = value;\n    else if (value === false || value === null || value === undefined)\n        node.removeAttribute(attr);\n    else node.setAttribute(attr, value);\n}\n\n/**\n * Applies an effect to a node, so that when the node is disconnected, the effect is cleaned up.\n * @param {Node} node - The target node.\n * @param {Function} fn - The effect function to apply.\n * @returns {Function} The cleanup function for the effect.\n * @private\n */\nfunction setEffect(node, fn) {\n    const existingCleanup = node._cleanup;\n    if (existingCleanup) existingCleanup();\n    const cleanup = effect(fn);\n    node._cleanup = cleanup;\n    return cleanup;\n}\n\n/**\n * Replaces all nodes after MARKERNode with the new nodes.\n * @param {Node} MARKERNode - The marker node which marks the insertion point.\n * @param {Array<Node>} newNodes - The new nodes to insert.\n * @private\n */\nfunction replaceNodes(MARKERNode, newNodes) {\n    const parent = MARKERNode.parentNode;\n    let next = MARKERNode.nextSibling;\n\n    while (next && next.__nodeGroups) {\n        if (next._cleanup) next._cleanup();\n        parent.removeChild(next);\n        next = MARKERNode.nextSibling;\n    }\n\n    if (newNodes?.length) {\n        insertFragment(\n            markedFragment(newNodes),\n            parent,\n            MARKERNode.nextSibling\n        );\n    }\n}\n\n/**\n * Updates the content of a node with a new value.\n *\n * If the new value is an array, it is treated as a list of nodes and the\n * reconciliation algorithm is used to update the content.\n *\n * If the new value is any other type, it is converted to a string and set\n * as the text content of a new text node, which is then inserted into the\n * document.\n *\n * If the new value is a function, it is called and the return value is used\n * as the new content.\n *\n * @param {Node} node - The target node.\n * @param {any} value - The new value to set as the content of the node.\n * @private\n */\nfunction applyContent(node, value) {\n    const updateContent = (val) => {\n        tryCatch(() => {\n            if (Array.isArray(val)) reconcile(val, node);\n            else {\n                const textNode = document.createTextNode(String(val ?? \"\"));\n                markNode(textNode);\n                replaceNodes(node, [textNode]);\n            }\n        }, \"html.updateContent\");\n    };\n\n    typeof value === \"function\"\n        ? setEffect(node, () => updateContent(value()))\n        : updateContent(value);\n}\n\n/**\n * Renders a node by applying an attribute or content.\n * If an attribute is provided, it removes the existing attribute, and depending\n * on its prefix, applies a reference, an event, or a regular attribute.\n * For reactive values, it applies an effect to update the attribute.\n * Otherwise, it updates the content of the node.\n *\n * @param {Node} node - The target node to render.\n * @param {string|null} attr - The attribute to process or null for content.\n * @param {any} value - The value to apply to the node.\n * @private\n */\n\nconst render = (node, attr, value) => {\n    if (attr) {\n        node.removeAttribute(attr);\n\n        if (attr === \"ref\") setRef(node, value);\n        else if (attr[0] == \"o\" && attr[1] == \"n\") setEvent(node, attr, value);\n        else if (attr === \"className\") node.setAttribute(\"class\", value);\n        else if (attr === \"style\" && typeof value === \"object\")\n            setEffect(node, () => setStyle(node, value));\n        else {\n            // If the value is reactive, apply effect\n            typeof value === \"function\"\n                ? setEffect(node, () => setAttribute(node, attr, value()))\n                : setAttribute(node, attr, value);\n        }\n    }\n    // Render node content\n    else applyContent(node, value);\n};\n\n/**\n * Processes the attributes of a node.\n * Iterates over each attribute of the node and, if the attribute's value matches\n * the defined marker, calls the render function to apply the corresponding data value.\n *\n * @param {Node} node - The node whose attributes are to be processed.\n * @param {Array} data - An array of data values for interpolation.\n * @param {number} idx - The current index within the data array.\n * @returns {number} The updated index after processing.\n * @private\n */\n\nfunction processAttributes(node, data, idx) {\n    const attrs = Array.from(node.attributes);\n    for (const attr of attrs) {\n        if (attr.value === MARKER) render(node, attr.name, data[idx++]);\n    }\n    return idx;\n}\n\n/**\n * Processes a text node.\n * If the node is a marker, it is replaced by a comment and the corresponding data value is rendered.\n * If the node is not a marker, it is converted to a template and any comment nodes it contains are rendered.\n * @param {Node} node - The text node to be processed.\n * @param {Array} data - An array of data values for interpolation.\n * @param {number} idx - The current index within the data array.\n * @returns {number} The updated index after processing.\n * @private\n */\nfunction processTextNode(node, data, idx) {\n    if (node.nodeValue === MARKER) {\n        const comm = document.createComment(\"\");\n        node.replaceWith(comm);\n        render(comm, null, data[idx++]);\n    } else {\n        const tmp = createTemplate(node.nodeValue.replaceAll(MARKER, \"<!>\"));\n        for (const child of Array.from(tmp.content.childNodes)) {\n            if (child.nodeType === 8) render(child, null, data[idx++]);\n        }\n        node.replaceWith(tmp.content);\n    }\n    return idx;\n}\n\n/**\n * Creates an HTML template element from a string of HTML content.\n * @param {string} htmlContent - The HTML content to be converted to a template.\n * @returns {HTMLTemplateElement} The created template element.\n * @private\n */\nfunction createTemplate(htmlContent) {\n    const template = document.createElement(\"template\");\n    template.innerHTML = htmlContent;\n    return template;\n}\n\n/**\n * Converts an HTML string into an array of DOM nodes.\n * @param {string} htmlContent - The HTML content to be converted to nodes.\n * @param {Function} [fn=null] - Optional function to process the created template element.\n * @returns {Array<Node>} The array of created nodes.\n * @private\n */\nfunction templateToNodes(htmlContent, fn = null) {\n    return tryCatch(\n        () => {\n            const template = createTemplate(htmlContent);\n            if (typeof fn === \"function\") fn(template);\n            return [...template.content.childNodes];\n        },\n        \"html.templateToNodes\",\n        []\n    );\n}\n\n/**\n * Collects all nodes from a template content.\n * @param {HTMLTemplateElement} template - Template element to collect nodes from.\n * @returns {Array<Node>} Array of collected nodes.\n * @private\n */\nfunction collectNodes(template) {\n    const nodes = [];\n    const tw = document.createTreeWalker(template.content, 1 | 4);\n    let node;\n    while ((node = tw.nextNode())) nodes.push(node);\n    return nodes;\n}\n\n/**\n * Builds DOM nodes from a template and data.\n * @param {Array<string>} tpl - Template strings\n * @param {...any} data - Data to be interpolated into the template\n * @returns {Array<Node>} Created nodes\n * @private\n */\nfunction build(tpl, ...data) {\n    return tryCatch(\n        () => {\n            if (tpl.length === 1) return templateToNodes(tpl[0]);\n            if (!data.length) return templateToNodes(tpl.join(\"\"));\n\n            return templateToNodes(tpl.join(MARKER), (template) => {\n                const nodes = collectNodes(template);\n                let idx = 0;\n\n                for (const n of nodes) {\n                    if (n.nodeType === 1 && n.attributes.length) {\n                        idx = processAttributes(n, data, idx);\n                    } else if (n.nodeType === 3 && n.nodeValue.includes(MARKER))\n                        idx = processTextNode(n, data, idx);\n                }\n\n                return nodes;\n            });\n        },\n        \"html.build\",\n        []\n    );\n}\n\n/**\n * Creates DOM nodes from a template string and optional data\n * @param {Array<string>} tpl - Template strings\n * @param {...any} data - Data to be interpolated into the template\n * @returns {Array<Node>} Created nodes\n */\nfunction html(tpl, ...data) {\n    if (templCache.has(tpl)) return build(templCache.get(tpl), ...data);\n\n    templCache.set(tpl, tpl);\n    return build(tpl, ...data);\n}\n\nexport { html };\n", "import { handleError, tryCatch } from \"./utils/error\";\n\nconst lifecycles = {\n    beforeMount: [],\n    mount: [],\n    beforeUpdate: [],\n    update: [],\n    destroy: [],\n};\n\n/**\n * Adds a hook to the lifecycle system.\n *\n * @param {string} key - The lifecycle key identifying the set of hooks to add the function to.\n * @param {Function} fn - The function to add to the lifecycle hook.\n * @returns {Function} A function to remove the hook.\n */\nexport const addHook = (key, fn) => {\n    if (typeof fn !== \"function\") {\n        handleError(\"lifecycle\", \"Hook must be a function\");\n        return () => {};\n    }\n    const hooks = lifecycles[key];\n    if (!hooks) return () => {};\n    hooks.push(fn);\n    return () => {\n        const index = hooks.indexOf(fn);\n        if (index !== -1) hooks.splice(index, 1);\n    };\n};\n\n/**\n * Executes all hooks associated with the given lifecycle key within a provided context.\n *\n * @param {string} key - The lifecycle key identifying the set of hooks to run.\n * @param {Object} ctx - The context object to bind as `this` within each hook function.\n *                        If no context is provided, the function will return without executing hooks.\n */\nexport const runHook = (key, ctx) => {\n    if (!ctx || !lifecycles[key]) return;\n    for (const fn of lifecycles[key])\n        queueMicrotask(() => tryCatch(() => fn.call(ctx), \"lifecycle.runHook\"));\n};\n\n/**\n * Clears all hooks associated with the given lifecycle key.\n *\n * @param {string} key - The lifecycle key identifying the set of hooks to clear.\n */\nexport const clearHook = (key) => {\n    if (lifecycles[key]) lifecycles[key] = [];\n};\n\n/**\n * Registers an effect with automatic cleanup when destroying.\n *\n * The effect function may return a cleanup function, which will be registered as a\n * hook for the `destroy` lifecycle event.\n *\n * @param {Function} fn - The effect function to register.\n * @returns {Function} A function to remove the effect.\n */\nexport const onEffect = (fn) => {\n    const cleanup = fn();\n    return typeof cleanup === \"function\"\n        ? addHook(\"destroy\", cleanup)\n        : () => {};\n};\n\n// Public Hooks API\nexport const beforeMount = (fn) => addHook(\"beforeMount\", fn);\nexport const onMount = (fn) => addHook(\"mount\", fn);\nexport const beforeUpdate = (fn) => addHook(\"beforeUpdate\", fn);\nexport const onUpdate = (fn) => addHook(\"update\", fn);\nexport const onDestroy = (fn) => addHook(\"destroy\", fn);\n", "/**\n * Sanitizes text strings to prevent HTML injection\n * @param {any} value - Value to sanitize\n * @returns {string} Sanitized text\n */\nexport const sanitizeHtml = (value) =>\n    value == null\n        ? \"\"\n        : String(value).replace(\n              /[&<>'\"]/g,\n              (c) =>\n                  ({\n                      \"&\": \"&amp;\",\n                      \"<\": \"&lt;\",\n                      \">\": \"&gt;\",\n                      \"'\": \"&#39;\",\n                      '\"': \"&quot;\",\n                  }[c])\n          );\n", "import { signal } from \"./hooks/reactivity\";\nimport { sanitizeHtml } from \"./utils/parser\";\nimport { tryCatch } from \"./utils/error\";\n\n// Special values as constant object\nconst SPECIAL_VALUES = {\n    true: true,\n    false: false,\n    null: null,\n    undefined: undefined,\n    nan: NaN,\n    infinity: Infinity,\n    \"-infinity\": -Infinity,\n};\n\n/**\n * Parses a raw input value and attempts to convert it to a more appropriate JavaScript type.\n *\n * If the input is not a string, it is returned as is.\n * The function trims the input string and converts it to lowercase to check for special values\n * such as true, false, null, etc. If the trimmed string matches a special value, the corresponding\n * JavaScript type is returned. If the string can be converted to a number, the numeric value is\n * returned. If the string is in a JSON format (object or array), it attempts to parse it as JSON.\n * If all conversions fail, the original trimmed string is returned.\n *\n * @param {any} raw - The raw input value to be parsed.\n * @returns {any} The parsed value converted to an appropriate JavaScript type, or the original\n * value if no conversion is possible.\n */\n\nfunction parseValue(raw) {\n    if (typeof raw !== \"string\") return raw;\n    const str = raw.trim();\n    const lower = str.toLowerCase();\n\n    return (\n        SPECIAL_VALUES[lower] ??\n        (/^[\\d.]+$/.test(str)\n            ? parseFloat(str)\n            : str[0] === \"{\" || str[0] === \"[\"\n            ? parseJson(str)\n            : str)\n    );\n}\n\nfunction parseJson(str) {\n    try {\n        return JSON.parse(str);\n    } catch {}\n}\n\nconst shouldSkipAttribute = (name) =>\n    name.startsWith(\"ref\") || name.startsWith(\"on\");\n\n/**\n * Initializes properties from attributes of a host element.\n *\n * Iterates over the attributes of the element and sets the corresponding property in the host's `props` object to a reactive signal.\n * The value of the signal is obtained by parsing the attribute value with the `parseValue` function.\n *\n * @param {HTMLElement} host - The element whose attributes are to be used to initialize its properties.\n */\nconst initAttributes = (host) => {\n    const attrs = host.attributes;\n    for (let i = 0; i < attrs.length; i++) {\n        const { name, value } = attrs[i];\n        // Skip special attributes\n        if (shouldSkipAttribute(name)) continue;\n        host.props[name] = signal(parseValue(sanitizeHtml(value)));\n    }\n};\n\n/**\n * Observes changes to the attributes of a host element and updates corresponding reactive signals.\n *\n * This function sets up a MutationObserver that listens for attribute changes on the specified host element.\n * When an attribute changes, it checks if there is a corresponding reactive signal in the host's `props` object.\n * If a signal exists, it updates the signal with the new value of the attribute, parsed using the `parseValue` function.\n * The observer is added to the host's cleanup actions to ensure it is disconnected when no longer needed.\n *\n * @param {HTMLElement} host - The element whose attributes are to be observed for changes.\n */\n\nconst observeAttributes = (host) => {\n    const observer = new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            const attrName = mutation.attributeName;\n            if (!attrName) continue;\n            if (shouldSkipAttribute(attrName)) continue;\n            const sig = host.props[attrName];\n            if (sig) sig(parseValue(host.getAttribute(attrName) || \"\"));\n        }\n    });\n\n    observer.observe(host, { attributes: true });\n    host._cleanup.push(() => observer.disconnect());\n};\n\n/**\n * Initializes properties from attributes and observes future attribute changes.\n *\n * Initializes properties from attributes of the host element by calling `initAttributes`.\n * Then, sets up a MutationObserver to observe future attribute changes on the host element and updates the corresponding properties.\n *\n * @param {HTMLElement} host - The element whose properties are to be initialized and attributes observed.\n *\n * @see initAttributes\n * @see observeAttributes\n */\nexport const initPropsAndObserve = (host) => {\n    tryCatch(() => {\n        initAttributes(host);\n        observeAttributes(host);\n    }, \"props.initPropsAndObserve\");\n};\n", "import { emit } from \"./hooks/emit\";\n\n/**\n * Initializes the event broadcasting system in a component\n * @param {HTMLElement} host - Host element for events\n */\nexport function initDispatch(host) {\n    if (!host) return;\n    host.emit = (event, detail) => emit(event, detail, host);\n}\n", "import { runHook } from \"./lifecycle\";\nimport { initPropsAndObserve } from \"./props\";\nimport { initDispatch } from \"./events\";\nimport { createFragment } from \"./utils/dom\";\nimport { handleError as error, tryCatch } from \"./utils/error\";\n\nconst REGEX_TAG_NAME = /^[a-z][a-z0-9-]*$/;\nconst SHADOW_MODE = \"open\"; // closed || open\n\n/**\n * A base class for creating custom elements that provides an API for working\n * with properties, events, and the component lifecycle.\n *\n * @param {function} [setup] An optional function that is called when the\n *     component is initialized. It is passed the component's properties as an\n *     argument and should return a value that can be rendered into the\n *     component's shadow DOM.\n * @param {object} [options] An optional object with options for the component.\n *     Currently only the `mode` option is supported, which can be either\n *     `\"open\"` or `\"closed\"` and determines whether the component's shadow DOM\n *     is open or closed.\n *\n * @returns {class} A class that extends `HTMLElement` and provides the\n *     following additional properties and methods:\n *\n *     - `#shadow`: The component's shadow DOM.\n *     - `props`: An object containing the component's properties.\n *     - `_cleanup`: An array of functions that are called when the component is\n *         destroyed.\n *     - `_isMounted`: A boolean indicating whether the component is currently\n *         mounted.\n *     - `constructor()`: Initializes the component and calls the `setup`\n *         function if it is provided.\n *     - `connectedCallback()`: Called when the component is inserted into the\n *         DOM. It calls the `mount` lifecycle hook if the component is already\n *         mounted.\n *     - `disconnectedCallback()`: Called when the component is removed from the\n *         DOM. It calls the `destroy` lifecycle hook and then calls the\n *         functions in the `_cleanup` array.\n */\nconst BaseComponent = (setup, { mode } = {}) =>\n    class extends HTMLElement {\n        #shadow = this.attachShadow({ mode: mode || SHADOW_MODE });\n        props = Object.create(null);\n        _cleanup = [];\n \n        constructor() {\n            super();\n            tryCatch(() => {\n                // Initialize component\n                initDispatch(this);\n                initPropsAndObserve(this);\n\n                // Call setup function with props and render result\n                const result = setup?.call(this, this.props);\n                createFragment(\n                    [].concat(result).filter(Boolean),\n                    null,\n                    this.#shadow\n                );\n\n                // Run lifecycle hook\n                runHook(\"beforeMount\", this);\n            }, \"component.init\");\n        }\n\n        connectedCallback() {\n            runHook(\"mount\", this);\n         }\n\n        disconnectedCallback() {\n            runHook(\"destroy\", this);\n            for (let i = this._cleanup.length - 1; i >= 0; i--) {\n                tryCatch(this._cleanup[i], \"component.cleanup\");\n            }\n            this._cleanup.length = 0;\n        }\n    };\n\n/**\n * Registers a custom element with the given tag name and setup function.\n *\n * @param {string} tagName The tag name of the custom element.\n * @param {function} [setup] An optional function that is called when the\n *     component is initialized. It is passed the component's properties as an\n *     argument and should return a value that can be rendered into the\n *     component's shadow DOM.\n * @param {object} [options] An optional object with options for the component.\n *     Currently only the `mode` option is supported, which can be either\n *     `\"open\"` or `\"closed\"` and determines whether the component's shadow DOM\n *     is open or closed.\n *\n * @returns {undefined}\n */\nexport const component = (tagName, setup, options = {}) => {\n    if (!REGEX_TAG_NAME.test(tagName))\n        return error(\"component\", `Invalid tag name: ${tagName}`, \"error\");\n\n    if (customElements.get(tagName))\n        return error(\"component\", `${tagName} ya registrado`, \"warn\");\n\n    // Register the component\n    customElements.define(tagName, BaseComponent(setup, options));\n};\n"],
  "mappings": "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",
  "names": ["activeEffect", "runCount", "subs", "MAX_UPDATE_DEPTH", "signal", "__name", "initial", "val", "value", "computed", "sub", "effect", "fn", "updateDepth", "reactiveEffect", "prev", "computedSignal", "batch", "previous", "emit", "name", "detail", "target", "event", "__name", "ref", "initialValue", "current", "v", "__name", "markNode", "node", "__name", "markedFragment", "nodes", "createFragment", "fn", "parent", "frag", "handleError", "context", "error", "level", "method", "errorObj", "__name", "tryCatch", "fn", "fallback", "reconcile", "newGroupsData", "markerNode", "tryCatch", "parent", "removeNodes", "__name", "nodes", "node", "prevGroups", "prevMap", "g", "newGroups", "idx", "group", "keyNode", "n", "key", "state", "newMap", "lastNode", "newGroup", "prevGroup", "markedFragment", "fragment", "templCache", "MARKER", "insertFragment", "fragment", "parent", "node", "__name", "setRef", "value", "setEvent", "attr", "eventName", "setStyle", "setAttribute", "setEffect", "fn", "existingCleanup", "cleanup", "effect", "replaceNodes", "MARKERNode", "newNodes", "next", "markedFragment", "applyContent", "updateContent", "val", "tryCatch", "reconcile", "textNode", "markNode", "render", "processAttributes", "data", "idx", "attrs", "processTextNode", "comm", "tmp", "createTemplate", "child", "htmlContent", "template", "templateToNodes", "collectNodes", "nodes", "tw", "build", "tpl", "n", "html", "lifecycles", "addHook", "__name", "key", "fn", "handleError", "hooks", "index", "runHook", "ctx", "tryCatch", "clearHook", "onEffect", "cleanup", "beforeMount", "onMount", "beforeUpdate", "onUpdate", "onDestroy", "sanitizeHtml", "__name", "value", "c", "SPECIAL_VALUES", "parseValue", "raw", "str", "lower", "parseJson", "__name", "shouldSkipAttribute", "name", "initAttributes", "host", "attrs", "i", "value", "signal", "sanitizeHtml", "observeAttributes", "observer", "mutations", "mutation", "attrName", "sig", "initPropsAndObserve", "tryCatch", "initDispatch", "host", "event", "detail", "emit", "__name", "REGEX_TAG_NAME", "SHADOW_MODE", "BaseComponent", "__name", "setup", "mode", "_shadow", "_a", "__privateAdd", "__publicField", "tryCatch", "initDispatch", "initPropsAndObserve", "result", "createFragment", "__privateGet", "runHook", "i", "component", "tagName", "options", "handleError"]
}
