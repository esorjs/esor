{
  "version": 3,
  "sources": ["../src/hooks/reactivity.js", "../src/hooks/emit.js", "../src/hooks/ref.js", "../src/utils/parser.js", "../src/utils/dom.js", "../src/template/reconcile.js", "../src/template/html.js", "../src/utils/error.js", "../src/lifecycle.js", "../src/props.js", "../src/events.js", "../src/component.js"],
  "sourcesContent": ["let activeEffect = null;\nconst effectStack = [];\n\n/**\n * Creates a reactive signal that notifies subscribers when its value changes.\n * @param {any} initialValue - Initial value.\n * @returns {Function} - Getter/setter function to access and modify the value.\n */\nconst signal = (initial) => {\n  let val = initial;\n  const subs = new Set();\n  const getterSetter = (value) => {\n    if (value === undefined) {\n      if (activeEffect) subs.add(activeEffect);\n      return val;\n    }\n    const computed = typeof value === \"function\" ? value(val) : value;\n    if (!Object.is(computed, val)) {\n      val = computed;\n      subs.forEach((fn) => fn());\n    }\n    return val;\n  };\n  return getterSetter;\n};\n\n/**\n * Creates a reactive effect that runs automatically when its dependencies change.\n * @param {Function} callback - The function to execute when the effect is triggered.\n * @returns {Function} - A function to clean up the effect.\n */\nconst effect = (fn) => {\n  let isRunning = false;\n  const reactive = () => {\n    if (isRunning) return;\n    isRunning = true;\n    const prev = activeEffect;\n    activeEffect = reactive;\n    try {\n      fn();\n    } finally {\n      activeEffect = prev;\n      isRunning = false;\n    }\n  };\n  reactive();\n  return () => subs.delete(reactive);\n};\n\n/**\n * Creates a computed reactive value that is derived from other signals.\n * @param {Function} callback - The function to execute when the computed value is accessed.\n * @returns {Function} - A getter function with a `.dispose` method to clean up the computed value.\n */\nconst computed = (fn) => {\n  const computedSignal = signal();\n  effect(() => computedSignal(fn()));\n  return () => computedSignal();\n};\n\n/**\n * Batches multiple signal updates into a single update, optimizing rendering performance.\n * @param {Function} callback - The function to execute within the batch.\n * @returns {any} - The result of the callback function.\n */\n\nconst batch = (fn) => {\n  if (effectStack.length > 0) return fn();\n  effectStack.push(true);\n  try {\n    return fn();\n  } finally {\n    effectStack.pop();\n  }\n};\n\nexport { signal, effect, computed, batch };\n", "/**\n * Emits a custom event with the given name and detail\n * @param {string} name - name of the event\n * @param {*} detail - detail of the event\n * @param {EventTarget} [target=null] - target of the event\n * @returns {CustomEvent} - the emitted event\n */\nexport function emit(name, detail, target = null) {\n    const event = new CustomEvent(name, {\n        detail,\n        bubbles: true,\n        composed: true,\n        cancelable: true,\n    });\n\n    if (target) target.dispatchEvent(event);\n    return event;\n}\n", "/**\n * Creates a mutable reference to a value.\n *\n * @param {any} [initialValue=null] - The initial value for the reference.\n * @returns {Function} A getter/setter function for the reference value.\n */\nexport function ref(initialValue = null) {\n    let current = initialValue;\n    return (v) => (v !== undefined ? (current = v) : current);\n}\n", "/**\n * Sanitizes text strings to prevent HTML injection\n * @param {any} value - Value to sanitize\n * @returns {string} Sanitized text\n */\nexport const sanitizeHtml = (value) =>\n    value == null\n        ? \"\"\n        : String(value).replace(\n              /[&<>'\"]/g,\n              (c) =>\n                  ({\n                      \"&\": \"&amp;\",\n                      \"<\": \"&lt;\",\n                      \">\": \"&gt;\",\n                      \"'\": \"&#39;\",\n                      '\"': \"&quot;\",\n                  }[c])\n          );\n", "/**\n * Marks a node to identify it as system-generated\n * @param {Node} node - The node to be marked\n * @returns {Node} The same node, allowing for chaining\n */\n\nexport function markNode(node) {\n    if (node) node.__nodeGroups = true;\n    return node;\n}\n\n/**\n * Creates a DocumentFragment from an array of nodes, marking each node\n * to identify it as system-generated.\n * @param {Array<Node>} nodes - Nodes to include in the fragment.\n * @returns {DocumentFragment} The created DocumentFragment containing the marked nodes.\n */\nexport function markedFragment(nodes) {\n    return createFragment(nodes, markNode);\n}\n\n/**\n * Creates a DocumentFragment from an array of nodes, optionally processing each node with a function.\n * @param {Array<Node>} nodes - Nodes to include in the fragment.\n * @param {Function} [fn=null] - Optional function to process each node. The function takes the node and the fragment as parameters and returns a processed node.\n * @param {Node} [parent=null] - Optional parent node to append the fragment to.\n * @returns {DocumentFragment} The created DocumentFragment containing the nodes.\n */\nexport function createFragment(nodes, fn = null, parent = null) {\n    const frag = document.createDocumentFragment();\n    if (!nodes?.length) return frag;\n    for (let node of nodes) {\n        if (!node) continue;\n        node = typeof fn === \"function\" ? fn(node, frag) : node;\n        Array.isArray(node)\n            ? frag.appendChild(createFragment(node, fn))\n            : frag.appendChild(node);\n    }\n    if (parent && frag.childNodes.length) parent.appendChild(frag);\n    return frag;\n}\n", "import { markedFragment } from \"../utils/dom\";\n\n/**\n * Reconciles the DOM nodes by comparing new node groups with previous ones and updating the DOM accordingly.\n * This function efficiently updates the DOM by removing, adding, or reordering nodes based on a diff between\n * the current and new data. It ensures that the DOM reflects the changes in the data structure.\n *\n * @param {Array<Node|Array<Node>>} newGroupsData - An array of new node groups, where each group can be a single node or an array of nodes.\n * @param {Node} markerNode - A marker node used to determine the insertion point for new nodes in the DOM.\n *\n * Removes nodes that are no longer present in the new data, reuses nodes that haven't changed, and inserts new nodes\n * as needed. Handles cleanup by calling a _cleanup function on nodes if it exists before removing them.\n * Updates the internal __nodeGroups property of the marker node to reference the new groups.\n * Throws an error if the new data is invalid or if DOM operations fail.\n */\n\nexport function reconcile(newGroupsData, markerNode) {\n    if (!newGroupsData || !markerNode || !markerNode.parentNode) return;\n\n    const parent = markerNode.parentNode;\n\n    const removeNodes = (nodes) => {\n        for (const n of nodes) {\n            if (!n || n.parentNode !== parent) continue;\n            if (n._cleanup && typeof n._cleanup === \"function\") n._cleanup();\n            parent.removeChild(n);\n        }\n    };\n\n    const nodesChanged = (p, c) =>\n        p.length !== c.length || p.some((n, i) => !n.isEqualNode(c[i]));\n\n    const prevGroups = markerNode.__nodeGroups || [];\n    const prevMap = new Map(prevGroups.map((g) => [g.key, g]));\n\n    const newGroups = newGroupsData.map((nodes, idx) => {\n        const group = Array.isArray(nodes) ? nodes.filter(Boolean) : [nodes];\n\n        const keyNode = group.find((n) => n?.getAttribute?.(\"key\") != null);\n        const key = keyNode?.getAttribute(\"key\") || `__key_${idx}`;\n        return { key, nodes: group };\n    });\n\n    const newMap = new Map(newGroups.map((g) => [g.key, g]));\n\n    for (const g of prevGroups) !newMap.has(g.key) && removeNodes(g.nodes); // Remove groups that no longer exist in the new list.\n\n    let lastNode = markerNode;\n    for (const newGroup of newGroups) {\n        const prevGroup = prevMap.get(newGroup.key);\n\n        if (prevGroup) {\n            if (nodesChanged(prevGroup.nodes, newGroup.nodes)) {\n                //[UPDATE]\n                removeNodes(prevGroup.nodes);\n                parent.insertBefore(\n                    markedFragment(newGroup.nodes),\n                    lastNode.nextSibling\n                );\n            } else {\n                //  [KEEP/MOVE]\n                const refNode = lastNode.nextSibling;\n                if (prevGroup.nodes[0] !== refNode) {\n                    const frag = document.createDocumentFragment();\n                    for (const n of prevGroup.nodes) frag.appendChild(n);\n                    parent.insertBefore(frag, refNode);\n                }\n                newGroup.nodes = prevGroup.nodes; // Reuse nodes\n            }\n        } else {\n            // [ADD]\n            parent.insertBefore(\n                markedFragment(newGroup.nodes),\n                lastNode.nextSibling\n            );\n        }\n\n        lastNode = newGroup.nodes[newGroup.nodes.length - 1] || lastNode; // Update lastNode\n    }\n\n    markerNode.__nodeGroups = newGroups; // Update internal reference\n}\n", "import { sanitizeHtml } from \"../utils/parser\";\nimport { effect } from \"../hooks/reactivity\";\nimport { markedFragment, markNode } from \"../utils/dom\";\nimport { reconcile } from \"./reconcile\";\n\nconst templCache = new WeakMap();\nconst MARKER = \"\\ufeff\"; // Invisible marker for processing\n\n/**\n * Creates a <template> element from an HTML string.\n *\n * @param {string} htmlContent - The HTML string.\n * @returns {HTMLTemplateElement} The generated template.\n */\nfunction createTemplate(htmlContent) {\n    const template = document.createElement(\"template\");\n    template.innerHTML = htmlContent;\n    return template;\n}\n\n/**\n * Assigns attributes, events, or content to a node, as appropriate.\n *\n * @param {Node} node - The node to process.\n * @param {string|null} attr - The attribute name (or null for content).\n * @param {any} value - The value to assign.\n */\nconst render = (node, attr, value) => {\n    if (attr) {\n        node.removeAttribute(attr);\n        if (attr === \"ref\") {\n            typeof value === \"function\"\n                ? value(node)\n                : value && (value.current = node);\n        } else if (\n            attr[0] == \"o\" &&\n            attr[1] == \"n\" &&\n            typeof value === \"function\"\n        ) {\n            const eventName = attr.slice(2).toLowerCase();\n            node.addEventListener(eventName, value);\n            node._cleanup = () => node.removeEventListener(eventName, value);\n        } else if (attr === \"style\" && typeof value === \"object\") {\n            effect(() => Object.assign(node.style, value));\n        } else {\n            typeof value === \"function\"\n                ? effect(() => setAttribute(node, attr, value()))\n                : setAttribute(node, attr, value);\n        }\n        // Render node content\n    } else setContent(node, value);\n};\n\nexport function setAttribute(node, attr, value) {\n    if (attr === \"value\" || attr === \"checked\") node[attr] = value;\n    else if (value === false || value === null || value === undefined)\n        node.removeAttribute(attr);\n    else node.setAttribute(attr, value);\n}\n\n/**\n * Updates the content of a node.\n *\n * If the value is an array, the reconciliation algorithm is used.\n * Otherwise, a text node is created.\n *\n * @param {Node} node - The node to update.\n * @param {any} value - The new value.\n */\nfunction setContent(node, value) {\n    const updateContent = (val) => {\n        if (typeof val === \"boolean\") val = \"\";\n        if (Array.isArray(val)) reconcile(val, node);\n        else {\n            const textNode = document.createTextNode(\n                sanitizeHtml(typeof val === \"string\" ? val : String(val ?? \"\"))\n            );\n            markNode(textNode);\n            replaceNodes(node, [textNode]);\n        }\n    };\n\n    typeof value === \"function\"\n        ? effect(() => updateContent(value()))\n        : updateContent(value);\n}\n\n/**\n * Replaces all nodes following a marker node with new nodes.\n *\n * @param {Node} MARKERNode - The marker node.\n * @param {Array<Node>} newNodes - The new nodes to insert.\n */\nfunction replaceNodes(MARKERNode, newNodes) {\n    const parent = MARKERNode.parentNode;\n    let next = MARKERNode.nextSibling;\n    while (next && next.__nodeGroups) {\n        if (next._cleanup) next._cleanup();\n        parent.removeChild(next);\n        next = MARKERNode.nextSibling;\n    }\n    if (newNodes?.length) {\n        insertFragment(\n            markedFragment(newNodes),\n            parent,\n            MARKERNode.nextSibling\n        );\n    }\n}\n\n/**\n * Inserts a fragment into the DOM.\n *\n * @param {DocumentFragment} fragment - The fragment to insert.\n * @param {Node} parent - The parent node.\n * @param {Node|null} refNode - Reference node for insertion.\n */\nfunction insertFragment(fragment, parent, refNode = null) {\n    if (!fragment || !parent) return;\n    refNode && refNode.parentNode === parent\n        ? parent.insertBefore(fragment, refNode)\n        : parent.appendChild(fragment);\n}\n\n/**\n * Processes an HTML template and replaces markers with provided values.\n *\n * @param {HTMLTemplateElement} template - The template to process.\n * @param {Array<any>} data - The values to replace in the template.\n */\nfunction processTemplate(template, data) {\n    const nodes = [];\n    const walker = document.createTreeWalker(\n        template.content,\n        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT\n    );\n\n    while (walker.nextNode()) nodes.push(walker.currentNode);\n\n    let idx = 0;\n    for (let i = 0; i < nodes.length; i++) {\n        const n = nodes[i];\n        if (n.nodeType === Node.ELEMENT_NODE && n.attributes.length) {\n            for (const attr of Array.from(n.attributes))\n                if (attr.value === MARKER) render(n, attr.name, data[idx++]);\n        } else if (\n            n.nodeType === Node.TEXT_NODE &&\n            n.nodeValue.includes(MARKER)\n        ) {\n            if (n.nodeValue === MARKER) {\n                const comm = document.createComment(\"\");\n                n.parentNode.replaceChild(comm, n);\n                render(comm, null, data[idx++]);\n            } else {\n                const tmp = createTemplate(\n                    n.nodeValue.replaceAll(MARKER, \"<!>\")\n                );\n                const children = Array.from(tmp.content.childNodes);\n                for (let j = 0; j < children.length; j++) {\n                    const child = children[j];\n                    if (child.nodeType === Node.COMMENT_NODE)\n                        render(child, null, data[idx++]);\n                }\n                n.parentNode.replaceChild(tmp.content, n);\n            }\n        }\n    }\n}\n\n/**\n * Converts an HTML string into an array of nodes.\n *\n * @param {string} htmlContent - The HTML string.\n * @param {Function|null} [fn=null] - Optional function to process the template.\n * @returns {Array<Node>} The array of generated nodes.\n */\nfunction templateToNodes(htmlContent, fn = null) {\n    const template = createTemplate(htmlContent);\n    if (typeof fn === \"function\") fn(template);\n    return [...template.content.childNodes];\n}\n\n/**\n * Builds DOM nodes from a template and interpolation data.\n *\n * @param {Array<string>} tpl - The template parts.\n * @param {...any} data - The data to interpolate.\n * @returns {Array<Node>} The created nodes.\n */\nfunction build(tpl, ...data) {\n    if (tpl.length === 1) return templateToNodes(tpl[0]);\n    if (!data.length) return templateToNodes(tpl.join(\"\"));\n\n    const combined = tpl.join(MARKER);\n    const template = createTemplate(combined);\n    processTemplate(template, data);\n    return [...template.content.childNodes];\n}\n\n/**\n * Main function that creates DOM nodes from a template literal and interpolation data.\n *\n * @param {Array<string>} tpl - Template strings.\n * @param {...any} data - The data to interpolate.\n * @returns {Array<Node>} The created nodes.\n */\nfunction html(tpl, ...data) {\n    if (templCache.has(tpl)) return build(templCache.get(tpl), ...data);\n    templCache.set(tpl, tpl);\n    return build(tpl, ...data);\n}\n\nexport { html };\n", "/**\n * Handles errors centrally with context\n * @param {string} context - Context of error (module or function)\n * @param {Error|string} error - Error or message\n * @param {string} [level=\u201Cerror\u201D] - Log level (error, warn, info)\n * @returns {Error} Error processed for possible additional handling\n */\nexport function handleError(context, error, level = \"error\") {\n    const method = level === \"warn\" ? console.warn : console.error;\n    const errorObj = error instanceof Error ? error : new Error(String(error));\n    method(`[Esor Error] ${context}:`, errorObj.message);\n\n    return errorObj; // Allows chaining\n}\n", "import { handleError } from \"./utils/error\";\n\nlet ctx = null;\n\nexport const createLifecycle = (instance) => (ctx = instance);\n\n/**\n * Adds a hook to the lifecycle system.\n *\n * @param {string} key - The lifecycle key identifying the set of hooks to add the function to.\n * @param {Function} fn - The function to add to the lifecycle hook.\n * @returns {void}\n * @throws Error - If called outside component setup.\n */\nconst addHook = (key, fn) => {\n    if (!ctx) {\n        handleError(\"lifecycle\", \"Hook called outside component setup\");\n        return;\n    }\n    if (!ctx._lifecycles[key]) ctx._lifecycles[key] = [];\n    ctx._lifecycles[key].push(fn);\n};\n\n/**\n * Executes all hooks associated with the given lifecycle key within a provided context.\n *\n * @param {string} key - The lifecycle key identifying the set of hooks to run.\n * @returns {void}\n * @throws Error - If called outside component setup.\n */\nexport const runHook = (key) => {\n    if (!ctx?._lifecycles?.[key]) return;\n    for (const fn of ctx._lifecycles[key])\n        queueMicrotask(() => fn.call(ctx), \"lifecycle.runHook\");\n};\n\n/**\n * Registers an effect with automatic cleanup when destroying.\n *\n * The effect function may return a cleanup function, which will be registered as a\n * hook for the `destroy` lifecycle event.\n *\n * @param {Function} fn - The effect function to register.\n * @returns {Function} A function to remove the effect.\n */\nexport const onEffect = (fn) => {\n    const cleanup = fn();\n    return typeof cleanup === \"function\"\n        ? addHook(\"destroy\", cleanup)\n        : () => {};\n};\n\n// Public Hooks API\nexport const beforeMount = (fn) => addHook(\"beforeMount\", fn);\nexport const onMount = (fn) => addHook(\"mount\", fn);\nexport const beforeUpdate = (fn) => addHook(\"beforeUpdate\", fn);\nexport const onUpdate = (fn) => addHook(\"update\", fn);\nexport const onDestroy = (fn) => addHook(\"destroy\", fn);\n", "import { signal } from \"./hooks/reactivity\";\n\n/**\n * Initializes properties from attributes of a host element and observes future attribute changes.\n *\n * Iterates over the attributes of the host element and sets the corresponding property in the host's `props` object to a reactive signal.\n * The value of the signal is obtained by parsing the attribute value with the `parseAttributeValue` function.\n * Then, sets up a MutationObserver to observe future attribute changes on the host element and updates the corresponding properties.\n * The observer is added to the host's cleanup actions to ensure it is disconnected when no longer needed.\n *\n * @param {HTMLElement} host - The element whose attributes are to be used to initialize its properties.\n */\nexport function initPropsAndObserve(host) {\n    for (const attr of host.attributes) {\n        const { name, value } = attr;\n        if (name.startsWith(\"on\") || name.startsWith(\"ref\")) continue;\n        host.props[name] = signal(parseAttributeValue(value));\n    }\n\n    // Observe future changes in attributes\n    const observer = new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            const name = mutation.attributeName;\n            if (!name || name.startsWith(\"on\") || name.startsWith(\"ref\"))\n                continue;\n\n            const sig = host.props[name];\n            if (sig) sig(parseAttributeValue(host.getAttribute(name)));\n        }\n    });\n\n    observer.observe(host, { attributes: true });\n    host._cleanup.push(() => observer.disconnect());\n}\n\n/**\n * Parsea un valor de atributo a un tipo JS apropiado.\n *\n * Convierte un valor de atributo a un tipo JS apropiado. Si el valor es nulo o indefinido,\n * devuelve una cadena vac . Si el valor es \"true\" o \"false\", devuelve el valor booleano\n * correspondiente. Si el valor se puede parsear como un n mero (utilizando una expresi n\n * regular), devuelve el n mero. Si el valor se puede parsear como un objeto o arreglo JSON\n * (utilizando una expresi n regular y JSON.parse), devuelve el objeto o arreglo. En caso\n * contrario, devuelve el valor original.\n *\n * @param {any} value - El valor del atributo a parsear.\n * @returns {any} El valor parseado.\n */\nfunction parseAttributeValue(value) {\n    if (value === null || value === undefined) return \"\";\n    if (value === \"true\") return true;\n    if (value === \"false\") return false;\n    if (/^-?\\d+(\\.\\d+)?$/.test(value)) return Number(value);\n    if (/^[{[]/.test(value)) {\n        try {\n            return JSON.parse(value);\n        } catch {\n            return value;\n        }\n    }\n    return value;\n}\n", "import { emit } from \"./hooks/emit\";\n\n/**\n * Initializes the event broadcasting system in a component\n * @param {HTMLElement} host - Host element for events\n */\nexport function initDispatch(host) {\n    if (!host) return;\n    host.emit = (event, detail) => emit(event, detail, host);\n}\n", "import { createLifecycle, runHook } from \"./lifecycle.js\";\nimport { initPropsAndObserve } from \"./props.js\";\nimport { initDispatch } from \"./events.js\";\nimport { createFragment } from \"./utils/dom.js\";\nimport { handleError as error } from \"./utils/error.js\";\n\nconst REGEX_TAG_NAME = /^[a-z][a-z0-9-]*$/;\nconst SHADOW_MODE = \"open\"; // closed || open\n\n/**\n * A base class for creating custom elements that provides an API for working\n * with properties, events, and the component lifecycle.\n *\n * @param {function} [setup] An optional function that is called when the\n *     component is initialized. It is passed the component's properties as an\n *     argument and should return a value that can be rendered into the\n *     component's shadow DOM.\n * @param {object} [options] An optional object with options for the component.\n *     Currently only the `mode` option is supported, which can be either\n *     `\"open\"` or `\"closed\"` and determines whether the component's shadow DOM\n *     is open or closed.\n *\n * @returns {class} A class that extends `HTMLElement` and provides the\n *     following additional properties and methods:\n *\n *     - `#shadow`: The component's shadow DOM.\n *     - `props`: An object containing the component's properties.\n *     - `_cleanup`: An array of functions that are called when the component is\n *         destroyed.\n *     - `_isMounted`: A boolean indicating whether the component is currently\n *         mounted.\n *     - `constructor()`: Initializes the component and calls the `setup`\n *         function if it is provided.\n *     - `connectedCallback()`: Called when the component is inserted into the\n *         DOM. It calls the `mount` lifecycle hook if the component is already\n *         mounted.\n *     - `disconnectedCallback()`: Called when the component is removed from the\n *         DOM. It calls the `destroy` lifecycle hook and then calls the\n *         functions in the `_cleanup` array.\n */\nconst BaseComponent = (setup, options = {}) =>\n    class extends HTMLElement {\n        #shadow = this.attachShadow({ mode: options.mode || SHADOW_MODE });\n        #mounted = false;\n        props = Object.create(null);\n        _lifecycles = {\n            beforeMount: [],\n            mount: [],\n            beforeUpdate: [],\n            update: [],\n            destroy: [],\n        };\n        _cleanup = [];\n\n        constructor() {\n            super();\n            queueMicrotask(() => {\n                // Initialize component\n                createLifecycle(this);\n                initDispatch(this);\n                initPropsAndObserve(this);\n\n                // Call setup function with props and render result\n                const result = setup?.call(this, this.props);\n                createFragment(result || [result], null, this.#shadow);\n\n                runHook(\"beforeMount\");\n            });\n        }\n\n        connectedCallback() {\n            if (this.#mounted) return;\n            this.#mounted = true;\n            runHook(\"mount\");\n        }\n\n        disconnectedCallback() {\n            runHook(\"destroy\");\n            this._cleanup.forEach((cleanup) => cleanup());\n            this._cleanup = [];\n            this.#mounted = false;\n        }\n    };\n\n/**\n * Registers a custom element with the given tag name and setup function.\n *\n * @param {string} tagName The tag name of the custom element.\n * @param {function} [setup] An optional function that is called when the\n *     component is initialized. It is passed the component's properties as an\n *     argument and should return a value that can be rendered into the\n *     component's shadow DOM.\n * @param {object} [options] An optional object with options for the component.\n *     Currently only the `mode` option is supported, which can be either\n *     `\"open\"` or `\"closed\"` and determines whether the component's shadow DOM\n *     is open or closed.\n *\n * @returns {undefined}\n */\nexport const component = (tagName, setup, options = {}) => {\n    if (typeof customElements == \"undefined\") return;\n    if (!REGEX_TAG_NAME.test(tagName))\n        return error(\"component\", `Invalid tag name: ${tagName}`, \"error\");\n    if (customElements.get(tagName))\n        return error(\"component\", `${tagName} already registered`, \"warn\");\n\n    // Register the component\n    customElements.define(tagName, BaseComponent(setup, options));\n};\n"],
  "mappings": "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",
  "names": ["activeEffect", "effectStack", "signal", "__name", "initial", "val", "subs", "value", "computed", "fn", "effect", "isRunning", "reactive", "prev", "computedSignal", "batch", "emit", "name", "detail", "target", "event", "__name", "ref", "initialValue", "current", "v", "__name", "sanitizeHtml", "__name", "value", "c", "markNode", "node", "__name", "markedFragment", "nodes", "createFragment", "fn", "parent", "frag", "reconcile", "newGroupsData", "markerNode", "parent", "removeNodes", "__name", "nodes", "n", "nodesChanged", "p", "c", "i", "prevGroups", "prevMap", "g", "newGroups", "idx", "group", "newMap", "lastNode", "newGroup", "prevGroup", "markedFragment", "refNode", "frag", "templCache", "MARKER", "createTemplate", "htmlContent", "template", "__name", "render", "node", "attr", "value", "eventName", "effect", "setAttribute", "setContent", "updateContent", "val", "reconcile", "textNode", "sanitizeHtml", "markNode", "replaceNodes", "MARKERNode", "newNodes", "parent", "next", "insertFragment", "markedFragment", "fragment", "refNode", "processTemplate", "data", "nodes", "walker", "idx", "i", "n", "comm", "tmp", "children", "j", "child", "templateToNodes", "fn", "build", "tpl", "combined", "html", "handleError", "context", "error", "level", "method", "errorObj", "__name", "ctx", "createLifecycle", "__name", "instance", "addHook", "key", "fn", "handleError", "runHook", "onEffect", "cleanup", "beforeMount", "onMount", "beforeUpdate", "onUpdate", "onDestroy", "initPropsAndObserve", "host", "attr", "name", "value", "signal", "parseAttributeValue", "observer", "mutations", "mutation", "sig", "__name", "initDispatch", "host", "event", "detail", "emit", "__name", "REGEX_TAG_NAME", "SHADOW_MODE", "BaseComponent", "__name", "setup", "options", "_shadow", "_mounted", "_a", "__privateAdd", "__publicField", "createLifecycle", "initDispatch", "initPropsAndObserve", "result", "createFragment", "__privateGet", "runHook", "__privateSet", "cleanup", "component", "tagName", "handleError"]
}
